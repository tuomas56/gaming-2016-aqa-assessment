import random
import time
import sys

WE_ARE_RUNNING_IN_IDLE = False
#IDLE doesn't support clearing the screen, so we need to know if we are using it or not.
#Change this if you *are* running this in IDLE.

NotValidException = Exception()
#a special exception thrown whenever a validation function is passed invalid input

#this is an iterator.
#an iterator 'yield's results and
#the results can be generated by
#doing 'for ... in iterator:'
#a list of them can be generated with 'list(iterator)'
def chunks(l, n):
#chunks(l:iterator[T], n:int) -> iterator[tuple[T]]
#split a list into evenly sized chunks.
    for i in range(0, len(l), n):
        #iterate with a step of n
        yield l[i:i+n]
        #yield a block of length n

#a function that gets user input, validates and processes it.
def get(conv, prompt, error="Invalid input."):
#get(conv:callable(str) -> T, prompt:str, error:str) -> T
#loop until the user inputs a valid string
    while True:
        try:
            return conv(input(prompt))
            #ask the user for input and
            #convert the string with the conversion function and return it
        except EOFError:
            print("Can't Read Line! Exiting...")
            sys.exit()
        except:
            print(error)
            #if the conversion function errors, print the error message and loop

#displays and gets a choice from menu options
def menu(options:list, prompt:str="Please choose an option: ") -> int:
    print(prompt)
    #print the options like this
    #   1) OPTION
    for i,option in enumerate(options):
        print(" "*3,str(i+1)+")",option)
    def validate(x):
    #the function that will validate if the users input
    #is within number of options
        x = int(x)
        #int will error if x is not an int
        if x > len(options):
            raise NotValidException
        elif x < 1:
            raise NotValidException
        #error if the input is too big or too small.
        return x
    return get(validate,"Please enter an option [1-"+str(len(options))+"]: ") - 1
    #subtract 1 so that the option index starts at zero.

def nl(n:int=1) -> None:
#print n newlines
	print('\n'*(n-1))
	#print automatically ends with a newline so we print n - 1 \n characters

def load_words(extended:bool=False) -> list:
	with open("WordsExt.txt" if extended else "Words.txt") as f:
	#open a different file depending on whether or not we're using extended mode
		return list(map(str.strip, f.read().split("\n")))[:-1]
		#read all the text from that file, split it at the newlines, 
		#and call 'str.strip' on each of them. This removes extra spaces, etc.
		#then ditch the last element '[:-1]' because it is an empty line.

def ask_with_retry(prompt:str, correct:str) -> bool:
#ask for a five letter word, giving the user three guesses to get 'correct'.
	prompt += ' You have %s guesses remaining: '
	def validate(s):
	#the validation function for 'get'
	#this converts the entry to lower case and then checks to make sure it is five letters.
	#I could have checked if the word entered is in the list but decided not to.
			s = s.lower()
			if len(s) != 5:
				raise NotValidException
			return s

	for i in range(3, 0, -1):
	#use a range with -1 step to iterate backwards over the guesses: i = 3, 2, 1
		guess = get(validate, prompt % i)
		if guess == correct.lower():
			return True
	return False

def draw_grid(words:list, size:int) -> None:
#draw a grid from 'words' with 'size' rows
#it will draw as many words per row as needed
	for row in chunks(words, size):
		print(' '.join(row))

def clear_screen() -> None:
	if WE_ARE_RUNNING_IN_IDLE:
		print('\n'*60)
		#the average IDLE terminal is probably about 60 chars high.
	else:
		print(chr(27) + '[2J')
		#the ANSI control code for clear screen.

def end_game(guessed_removed:bool, guessed_replaced:bool, removed:str, replaced:str) -> None:
	if guessed_removed:
		print('You remembered which word was removed correctly!')
	else:
		print('The word which was removed was %s' % removed)

	if guessed_replaced:
		print('You remembered which word replaced it correctly!')
	else:
		print('The word which replaced it was %s' % replaced)

	print("You scored %s/2!" % (guessed_replaced + guessed_removed))
	#we can add guessed_replaced and guessed_removed because bool is a subclass of int.
	#i.e) True == 1 and False == 0

def play_game(words:list, size:int) -> int:
#since both normal and extended are very similar, we just create a function
#which takes a grid size argument. This is passed to the grid drawing, which
#is the only different part
	nl()
	input("Press <ENTER> to start.")
	print("You have 30 seconds to memorize the words.")
	nl(2)

	random.shuffle(words)
	words, replaced = words[:-1], words[-1]
	#the (normal) word list contains ten words, so shave of the last one and
	#use that to replace one later. The extended word list also contains 
	#one more that is needed so this still works.
	draw_grid(words, size)

	time.sleep(30)
	clear_screen()

	words[-1], removed = replaced, words[-1]
	#since we are shuffling it afterwards, we don't need to replace a random element,
	#so I just replace the last one. (Remembering that this is only nine words - we
	#already lopped of the tenth one.)
	random.shuffle(words)
	draw_grid(words, size)

	nl(2)

	guessed_removed = ask_with_retry('What word was removed?', removed)
	guessed_replaced = ask_with_retry('What word replaced it?', replaced)

	nl()

	end_game(guessed_removed, guessed_replaced, removed, replaced)

	nl(2)

	return main_menu()


def main_menu() -> int:
	choice = menu(['Normal Mode', 'Extended Mode', 'Exit'])
	if choice == 2: #Exit
		print("Goodbye!")
		return 0
		#error code zero means no error.
	elif choice == 0: #Normal Mode
		return play_game(load_words(extended=False), 3)
	elif choice == 1: #Extended Mode
		return play_game(load_words(extended=True), 4)

def main() -> int:
	print("Welcome to the Memory Game!")
	#we don't do this inside the menu function because that is called again later.
	nl()
	return main_menu()

if __name__ == "__main__":
#if this module is not being imported.
#i.e) if it's being run directly...
	sys.exit(main())
	#pass the error code returned from main to the system.